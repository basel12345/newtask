import { Injectable, ɵɵdefineInjectable, Input, EventEmitter, Directive, ElementRef, ChangeDetectorRef, Output, ɵɵinject, NgModule } from '@angular/core';
import { FormArray } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataTransferEffect {
    /**
     * @param {?} name
     */
    constructor(name) {
        this.name = name;
    }
}
DataTransferEffect.COPY = new DataTransferEffect('copy');
DataTransferEffect.LINK = new DataTransferEffect('link');
DataTransferEffect.MOVE = new DataTransferEffect('move');
DataTransferEffect.NONE = new DataTransferEffect('none');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DragDropConfig {
    constructor() {
        this.onDragStartClass = 'dnd-drag-start';
        this.onDragEnterClass = 'dnd-drag-enter';
        this.onDragOverClass = 'dnd-drag-over';
        this.onSortableDragClass = 'dnd-sortable-drag';
        this.dragEffect = DataTransferEffect.MOVE;
        this.dropEffect = DataTransferEffect.MOVE;
        this.dragCursor = 'move';
        this.defaultCursor = 'pointer';
    }
}
DragDropConfig.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ DragDropConfig.ngInjectableDef = ɵɵdefineInjectable({ factory: function DragDropConfig_Factory() { return new DragDropConfig(); }, token: DragDropConfig, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DragDropService {
    constructor() {
        this.allowedDropZones = [];
    }
}
DragDropService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */ DragDropService.ngInjectableDef = ɵɵdefineInjectable({ factory: function DragDropService_Factory() { return new DragDropService(); }, token: DragDropService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class AbstractHandleDirective {
    /**
     * @param {?} elementReference
     * @param {?} dragDropService
     * @param {?} config
     * @param {?} directive
     */
    constructor(elementReference, dragDropService, config, directive) {
        this.dragDropService = dragDropService;
        this.config = config;
        this.directive = directive;
        this.element = elementReference.nativeElement;
        this.directive.dragHandle = this.element;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} obj
 * @return {?}
 */
function isPresent(obj) {
    return obj !== undefined && obj !== null;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} obj
 * @return {?}
 */
function isString(obj) {
    return typeof obj === 'string';
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SortableArrayHandler {
    /**
     * @param {?} sortableData
     * @param {?} index
     * @return {?}
     */
    getItemAt(sortableData, index) {
        return sortableData[index];
    }
    /**
     * @param {?} sortableData
     * @param {?} item
     * @return {?}
     */
    indexOf(sortableData, item) {
        return sortableData.indexOf(item);
    }
    /**
     * @param {?} sortableData
     * @param {?} index
     * @return {?}
     */
    removeItemAt(sortableData, index) {
        sortableData.splice(index, 1);
    }
    /**
     * @param {?} sortableData
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    insertItemAt(sortableData, item, index) {
        sortableData.splice(index, 0, item);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SortableFormArrayHandler {
    /**
     * @param {?} sortableData
     * @param {?} index
     * @return {?}
     */
    getItemAt(sortableData, index) {
        return sortableData.at(index);
    }
    /**
     * @param {?} sortableData
     * @param {?} item
     * @return {?}
     */
    indexOf(sortableData, item) {
        return sortableData.controls.indexOf(item);
    }
    /**
     * @param {?} sortableData
     * @param {?} index
     * @return {?}
     */
    removeItemAt(sortableData, index) {
        sortableData.removeAt(index);
    }
    /**
     * @param {?} sortableData
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    insertItemAt(sortableData, item, index) {
        sortableData.insert(index, item);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class AbstractDirective {
    /**
     * @param {?} elementReference
     * @param {?} dragDropService
     * @param {?} config
     * @param {?} cdr
     */
    constructor(elementReference, dragDropService, config, cdr) {
        this.dragDropService = dragDropService;
        this.config = config;
        this.cdr = cdr;
        this._dragEnabled = true;
        this.dropEnabled = false;
        this.dropZones = [];
        this.cloneItem = false;
        this.defaultCursor = this.config.defaultCursor;
        this.element = elementReference.nativeElement;
        this.element.style.cursor = this.defaultCursor;
        // Register drop events
        this.element.ondragenter = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.dragEnter(event));
        this.element.ondragleave = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.dragLeave(event));
        this.element.ondrop = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => this.drop(event));
        this.element.ondragover = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.dragOver(event);
            if (isPresent(event.dataTransfer)) {
                event.dataTransfer.dropEffect = this.config.dropEffect.name;
            }
            return false;
        });
        // Register drag events
        this.element.onmousedown = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.target = event.target;
        });
        this.element.ondragstart = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            if (isPresent(this.dragHandle)) {
                if (!this.dragHandle.contains((/** @type {?} */ (this.target)))) {
                    event.preventDefault();
                    return;
                }
            }
            this.dragStart(event);
            if (isPresent(event.dataTransfer)) {
                // Required so that this whole thing works in Firefox at all
                event.dataTransfer.setData('text', '');
            }
        });
        this.element.ondragend = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            if (this.element.parentElement && this.dragHelper) {
                this.element.parentElement.removeChild(this.dragHelper);
            }
            // console.log('ondragend', event.target);
            this.dragEnd(event);
            // Restore style of dragged element
            /** @type {?} */
            const cursorElem = this._dragHandle ? this._dragHandle : this.element;
            cursorElem.style.cursor = this.defaultCursor;
        });
    }
    /**
     * @return {?}
     */
    get dragEnabled() {
        return this._dragEnabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set dragEnabled(value) {
        this._dragEnabled = value;
        this.element.draggable = value;
    }
    /**
     * @return {?}
     */
    get dragHandle() {
        return this._dragHandle;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set dragHandle(value) {
        this._dragHandle = value;
    }
    /**
     * Run change detection manually to fix an issue in Safari.
     *
     * \@memberof AbstractDirective
     * @return {?}
     */
    detectChanges() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.cdr && !((/** @type {?} */ (this.cdr))).destroyed) {
                this.cdr.detectChanges();
            }
        }), 250);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    dragEnter(event) {
        if (this.isDropAllowed(event)) {
            this.dragEnterCallback(event);
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    dragOver(event) {
        if (this.isDropAllowed(event)) {
            if (isPresent(event.preventDefault)) {
                event.preventDefault();
            }
            this.dragOverCallback(event);
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    dragLeave(event) {
        if (this.isDropAllowed(event)) {
            this.dragLeaveCallback(event);
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    drop(event) {
        if (this.isDropAllowed(event)) {
            this.preventAndStop(event);
            this.dropCallback(event);
            this.detectChanges();
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    dragStart(event) {
        if (this.dragEnabled) {
            this.dragDropService.allowedDropZones = this.dropZones;
            this.dragStartCallback(event);
        }
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    dragEnd(event) {
        this.dragDropService.allowedDropZones = [];
        this.dragEndCallback(event);
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    isDropAllowed(event) {
        if ((this.dragDropService.isDragged ||
            (event.dataTransfer && event.dataTransfer.files)) &&
            this.dropEnabled) {
            if (isPresent(this.allowDrop)) {
                return this.allowDrop(this.dragDropService.dragData);
            }
            if (this.dropZones.length === 0 &&
                this.dragDropService.allowedDropZones.length === 0) {
                return true;
            }
            for (const dropZone of this.dragDropService.allowedDropZones) {
                if (this.dropZones.indexOf(dropZone) !== -1) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Prevent the given events default action from being called and stops it from being propagated further.
     *
     * \@memberof AbstractDirective
     * @private
     * @param {?} event
     * @return {?}
     */
    preventAndStop(event) {
        if (event.preventDefault) {
            event.preventDefault();
        }
        if (event.stopPropagation) {
            event.stopPropagation();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragEnterCallback(event) {
        /* noop */
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragOverCallback(event) {
        /* noop */
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragLeaveCallback(event) {
        /* noop */
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dropCallback(event) {
        /* noop */
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragStartCallback(event) {
        /* noop */
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragEndCallback(event) {
        /* noop */
    }
}
AbstractDirective.propDecorators = {
    dropEnabled: [{ type: Input }],
    effectAllowed: [{ type: Input }],
    effectCursor: [{ type: Input }],
    dropZones: [{ type: Input }],
    allowDrop: [{ type: Input }],
    dragImage: [{ type: Input }],
    cloneItem: [{ type: Input }],
    dragEnabled: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable directive-selector no-output-on-prefix */
class DraggableDirective extends AbstractDirective {
    /**
     * @param {?} elementReference
     * @param {?} dragDropService
     * @param {?} config
     * @param {?} cdr
     */
    constructor(elementReference, dragDropService, config, cdr) {
        super(elementReference, dragDropService, config, cdr);
        this.onDragStart = new EventEmitter();
        this.onDragEnd = new EventEmitter();
        this.onDragSuccess = new EventEmitter();
        this.defaultCursor = this.element.style.cursor;
        this.dragEnabled = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragStartCallback(event) {
        this.dragDropService.isDragged = true;
        this.dragDropService.dragData = this.dragData;
        this.dragDropService.onDragSuccessCallback = this.onDragSuccess;
        this.element.classList.add(this.config.onDragStartClass);
        this.onDragStart.emit({ dragData: this.dragData, mouseEvent: event });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragEndCallback(event) {
        this.dragDropService.isDragged = false;
        this.dragDropService.dragData = null;
        this.dragDropService.onDragSuccessCallback = null;
        this.element.classList.remove(this.config.onDragStartClass);
        this.onDragEnd.emit({ dragData: this.dragData, mouseEvent: event });
    }
}
DraggableDirective.decorators = [
    { type: Directive, args: [{ selector: '[dnd-draggable]' },] }
];
/** @nocollapse */
DraggableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: DragDropService },
    { type: DragDropConfig },
    { type: ChangeDetectorRef }
];
DraggableDirective.propDecorators = {
    dragData: [{ type: Input }],
    onDragStart: [{ type: Output }],
    onDragEnd: [{ type: Output }],
    onDragSuccess: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable directive-selector */
class DraggableHandleDirective extends AbstractHandleDirective {
    /**
     * @param {?} elementReference
     * @param {?} dragDropService
     * @param {?} config
     * @param {?} directive
     */
    constructor(elementReference, dragDropService, config, directive) {
        super(elementReference, dragDropService, config, directive);
    }
}
DraggableHandleDirective.decorators = [
    { type: Directive, args: [{ selector: '[dnd-draggable-handle]' },] }
];
/** @nocollapse */
DraggableHandleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: DragDropService },
    { type: DragDropConfig },
    { type: DraggableDirective }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable directive-selector no-output-on-prefix */
class DroppableDirective extends AbstractDirective {
    /**
     * @param {?} elementReference
     * @param {?} dragDropService
     * @param {?} config
     * @param {?} cdr
     */
    constructor(elementReference, dragDropService, config, cdr) {
        super(elementReference, dragDropService, config, cdr);
        this.onDropSuccess = new EventEmitter();
        this.onDragEnter = new EventEmitter();
        this.onDragOver = new EventEmitter();
        this.onDragLeave = new EventEmitter();
        this.dropEnabled = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragEnterCallback(event) {
        if (this.dragDropService.isDragged) {
            this.element.classList.add(this.config.onDragEnterClass);
            this.onDragEnter.emit({
                dragData: this.dragDropService.dragData,
                mouseEvent: event,
            });
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragOverCallback(event) {
        if (this.dragDropService.isDragged) {
            this.element.classList.add(this.config.onDragOverClass);
            this.onDragOver.emit({
                dragData: this.dragDropService.dragData,
                mouseEvent: event,
            });
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragLeaveCallback(event) {
        if (this.dragDropService.isDragged) {
            this.element.classList.remove(this.config.onDragOverClass);
            this.element.classList.remove(this.config.onDragEnterClass);
            this.onDragLeave.emit({
                dragData: this.dragDropService.dragData,
                mouseEvent: event,
            });
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dropCallback(event) {
        /** @type {?} */
        const dataTransfer = ((/** @type {?} */ (event))).dataTransfer;
        if (this.dragDropService.isDragged ||
            (isPresent(dataTransfer) && isPresent(dataTransfer.files))) {
            this.onDropSuccess.emit({
                dragData: this.dragDropService.dragData,
                mouseEvent: event,
            });
            if (isPresent(this.dragDropService.onDragSuccessCallback)) {
                this.dragDropService.onDragSuccessCallback.emit({
                    dragData: this.dragDropService.dragData,
                    mouseEvent: event,
                });
            }
            this.element.classList.remove(this.config.onDragOverClass);
            this.element.classList.remove(this.config.onDragEnterClass);
        }
    }
}
DroppableDirective.decorators = [
    { type: Directive, args: [{ selector: '[dnd-droppable]' },] }
];
/** @nocollapse */
DroppableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: DragDropService },
    { type: DragDropConfig },
    { type: ChangeDetectorRef }
];
DroppableDirective.propDecorators = {
    onDropSuccess: [{ type: Output }],
    onDragEnter: [{ type: Output }],
    onDragOver: [{ type: Output }],
    onDragLeave: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DragDropSortableService {
    /**
     * Creates an instance of DragDropSortableService.
     * \@memberof DragDropSortableService
     * @param {?} config The DragDropConfig.
     */
    constructor(config) {
        this.config = config;
    }
    /**
     * Gets the last element that was marked sortable.
     *
     * \@readonly
     * \@memberof DragDropSortableService
     * @return {?}
     */
    get element() {
        return this._element;
    }
    /**
     * Assigns the `onSortableDragClass` to the given element.
     *
     * \@memberof DragDropSortableService
     * @param {?} e The element to assign the CSS class to.
     * @return {?}
     */
    markSortable(e) {
        if (isPresent(this._element)) {
            this._element.classList.remove(this.config.onSortableDragClass);
        }
        if (isPresent(e)) {
            this._element = e;
            this._element.classList.add(this.config.onSortableDragClass);
        }
    }
}
DragDropSortableService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
DragDropSortableService.ctorParameters = () => [
    { type: DragDropConfig }
];
/** @nocollapse */ DragDropSortableService.ngInjectableDef = ɵɵdefineInjectable({ factory: function DragDropSortableService_Factory() { return new DragDropSortableService(ɵɵinject(DragDropConfig)); }, token: DragDropSortableService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable directive-selector */
class SortableContainerDirective extends AbstractDirective {
    /**
     * @param {?} elementRef
     * @param {?} dragDropService
     * @param {?} config
     * @param {?} cdr
     * @param {?} sortableDataService
     */
    constructor(elementRef, dragDropService, config, cdr, sortableDataService) {
        super(elementRef, dragDropService, config, cdr);
        this.sortableDataService = sortableDataService;
        this._sortableData = [];
        this.dragEnabled = false;
    }
    /**
     * @param {?} sortableData
     * @return {?}
     */
    set sortableData(sortableData) {
        this._sortableData = sortableData;
        if (sortableData instanceof FormArray) {
            this._sortableHandler = new SortableFormArrayHandler();
        }
        else {
            this._sortableHandler = new SortableArrayHandler();
        }
        this.dropEnabled = !!this._sortableData;
    }
    /**
     * @return {?}
     */
    get sortableData() {
        return this._sortableData;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragEnterCallback(event) {
        if (this.sortableDataService.isDragged) {
            /** @type {?} */
            const item = this.sortableDataService.sortableContainer.getItemAt(this.sortableDataService.index);
            if (this.indexOf(item === -1)) {
                this.sortableDataService.sortableContainer.removeItemAt(this.sortableDataService.index);
                if (this.sortableDataService.sortableContainer.sortableData.length === 0) {
                    this.sortableDataService.sortableContainer.dropEnabled = true;
                }
                this.insertItemAt(item, 0);
                this.sortableDataService.sortableContainer = this;
                this.sortableDataService.index = 0;
            }
            this.detectChanges();
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    getItemAt(index) {
        return this._sortableHandler.getItemAt(this._sortableData, index);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    indexOf(item) {
        return this._sortableHandler.indexOf(this._sortableData, item);
    }
    /**
     * @param {?} index
     * @return {?}
     */
    removeItemAt(index) {
        this._sortableHandler.removeItemAt(this._sortableData, index);
    }
    /**
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    insertItemAt(item, index) {
        this._sortableHandler.insertItemAt(this._sortableData, item, index);
    }
}
SortableContainerDirective.decorators = [
    { type: Directive, args: [{ selector: '[dnd-sortable-container]' },] }
];
/** @nocollapse */
SortableContainerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: DragDropService },
    { type: DragDropConfig },
    { type: ChangeDetectorRef },
    { type: DragDropSortableService }
];
SortableContainerDirective.propDecorators = {
    sortableData: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable directive-selector no-output-on-prefix */
class SortableDirective extends AbstractDirective {
    /**
     * @param {?} elementRef
     * @param {?} dragDropService
     * @param {?} config
     * @param {?} sortableContainer
     * @param {?} sortableDataService
     * @param {?} cdr
     */
    constructor(elementRef, dragDropService, config, sortableContainer, sortableDataService, cdr) {
        super(elementRef, dragDropService, config, cdr);
        this.sortableContainer = sortableContainer;
        this.sortableDataService = sortableDataService;
        this.onDragSuccess = new EventEmitter();
        this.onDragStart = new EventEmitter();
        this.onDragOver = new EventEmitter();
        this.onDragEnd = new EventEmitter();
        this.onDropSuccess = new EventEmitter();
        this.dropZones = this.sortableContainer.dropZones;
        this.dragEnabled = true;
        this.dropEnabled = true;
    }
    /**
     * @return {?}
     */
    dragStartCallback() {
        this.sortableDataService.isDragged = true;
        this.sortableDataService.sortableContainer = this.sortableContainer;
        this.sortableDataService.index = this.sortableIndex;
        this.sortableDataService.markSortable(this.element);
        this.dragDropService.isDragged = true;
        this.dragDropService.dragData = this.dragData;
        this.dragDropService.onDragSuccessCallback = this.onDragSuccess;
        this.onDragStart.emit(this.dragDropService.dragData);
    }
    /**
     * @return {?}
     */
    dragOverCallback() {
        if (this.sortableDataService.isDragged &&
            this.element !== this.sortableDataService.element) {
            this.sortableDataService.sortableContainer = this.sortableContainer;
            this.sortableDataService.index = this.sortableIndex;
            this.sortableDataService.markSortable(this.element);
            this.onDragOver.emit(this.dragDropService.dragData);
        }
    }
    /**
     * @return {?}
     */
    dragEndCallback() {
        this.sortableDataService.isDragged = false;
        this.sortableDataService.sortableContainer = null;
        this.sortableDataService.index = null;
        this.sortableDataService.markSortable(null);
        this.dragDropService.isDragged = false;
        this.dragDropService.dragData = null;
        this.dragDropService.onDragSuccessCallback = null;
        this.onDragEnd.emit(this.dragDropService.dragData);
    }
    /**
     * @return {?}
     */
    dragEnterCallback() {
        if (this.sortableDataService.isDragged) {
            this.sortableDataService.markSortable(this.element);
            if (this.sortableIndex !== this.sortableDataService.index ||
                this.sortableDataService.sortableContainer.sortableData !==
                    this.sortableContainer.sortableData) {
                /** @type {?} */
                const item = this.sortableDataService.sortableContainer.getItemAt(this.sortableDataService.index);
                this.sortableDataService.sortableContainer.removeItemAt(this.sortableDataService.index);
                if (this.sortableDataService.sortableContainer.sortableData.length === 0) {
                    this.sortableDataService.sortableContainer.dropEnabled = true;
                }
                this.sortableContainer.insertItemAt(item, this.sortableIndex);
                if (this.sortableContainer.dropEnabled) {
                    this.sortableContainer.dropEnabled = false;
                }
                this.sortableDataService.sortableContainer = this.sortableContainer;
                this.sortableDataService.index = this.sortableIndex;
                this.detectChanges();
            }
        }
    }
    /**
     * @return {?}
     */
    dropCallback() {
        if (this.sortableDataService.isDragged) {
            this.onDropSuccess.emit(this.dragDropService.dragData);
            if (this.dragDropService.onDragSuccessCallback) {
                this.dragDropService.onDragSuccessCallback.emit(this.dragDropService.dragData);
            }
            this.sortableContainer.detectChanges();
        }
    }
}
SortableDirective.decorators = [
    { type: Directive, args: [{ selector: '[dnd-sortable]' },] }
];
/** @nocollapse */
SortableDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: DragDropService },
    { type: DragDropConfig },
    { type: SortableContainerDirective },
    { type: DragDropSortableService },
    { type: ChangeDetectorRef }
];
SortableDirective.propDecorators = {
    sortableIndex: [{ type: Input }],
    dragData: [{ type: Input }],
    onDragSuccess: [{ type: Output }],
    onDragStart: [{ type: Output }],
    onDragOver: [{ type: Output }],
    onDragEnd: [{ type: Output }],
    onDropSuccess: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable directive-selector */
class SortableHandleDirective extends AbstractHandleDirective {
    /**
     * @param {?} elementRef
     * @param {?} dragDropService
     * @param {?} config
     * @param {?} directive
     */
    constructor(elementRef, dragDropService, config, directive) {
        super(elementRef, dragDropService, config, directive);
    }
}
SortableHandleDirective.decorators = [
    { type: Directive, args: [{ selector: '[dnd-sortable-handle]' },] }
];
/** @nocollapse */
SortableHandleDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: DragDropService },
    { type: DragDropConfig },
    { type: SortableDirective }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DndModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: DndModule,
            providers: [DragDropConfig],
        };
    }
}
DndModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    DraggableDirective,
                    DraggableHandleDirective,
                    DroppableDirective,
                    SortableContainerDirective,
                    SortableDirective,
                    SortableHandleDirective,
                ],
                exports: [
                    DraggableDirective,
                    DraggableHandleDirective,
                    DroppableDirective,
                    SortableContainerDirective,
                    SortableDirective,
                    SortableHandleDirective,
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DragImage {
    /**
     * @param {?} imageElement
     * @param {?=} x_offset
     * @param {?=} y_offset
     */
    constructor(imageElement, x_offset = 0, y_offset = 0) {
        this.imageElement = imageElement;
        this.x_offset = x_offset;
        this.y_offset = y_offset;
        if (isString(this.imageElement)) {
            /** @type {?} */
            const imgScr = this.imageElement;
            this.imageElement = new HTMLImageElement();
            this.imageElement.src = imgScr;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DragDropData {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { DataTransferEffect, DndModule, DragDropConfig, DragDropData, DragDropService, DragDropSortableService, DragImage, DraggableDirective, DraggableHandleDirective, DroppableDirective, SortableContainerDirective, SortableDirective, SortableHandleDirective, AbstractDirective as ɵa, AbstractHandleDirective as ɵb };
//# sourceMappingURL=beyerleinf-ngx-dnd.js.map
